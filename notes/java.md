# Recommendations for solving lab 2 with Java

The stub for lab 2 uses Java 21, which admits a more readable alternative to the visitor pattern suggested in the book. The following example code shows how you can process an object ```exp``` of the type ```Exp``` generated by the parser defined in the stub.

```java
switch(exp) {
    case EInt    e -> ... ;
    case EDouble e -> ... ;
    case EAnd    e -> ... ;
    case EOr    e -> ... ;
    ...
    default -> throw new IllegalStateException("Case for " + e + " is not yet implemented.");
}
```

On the right hand side of the ```->``` you can extract further information from ```e```, for example, in the case ```EAnd e```, you can use the two operands ```e.exp_1``` and ```e.exp_2```.

```switch```, if used like above produces a Java-expression, which means that you can use it in assignments:

```java
var typedExpression = switch(exp) { ... }
```

To define the neccessary datatypes, ```record```s are very useful. You can define a record like this:

```java
record TypedAnd(TypedExpr e1, TypedExpr e2) {
}
```

Objects of this type can be constructed with ```new TypedAnd(e1,e2)``` where ```e1``` and ```e2``` are ```TypedExpr```s. For solving the lab, it is reasonable to define an ```interface``` ```TypedExpr``` with a method which returns the type of an expression:

```java
interface TypedExpr {
  Type type();
}
```

Where ```Type``` is a datatype for types that needs to be defined. With this interface, the ```TypedAnd``` from above can be turned into an implementation like this:

```java
record TypedAnd(TypedExpr e1, TypedExpr e2) {
  Type type() {
    return new Type.Bool; // this is what it could look like if you implement basic types as an enum
  }
}
```

To keep a good overview, you can write implentations of an interface directly into the interface as "inner classes":

```java
interface TypedExpr {
  Type type();

  record And(TypedExpr e1, TypedExpr e2) implements TypedExpr {
    Type type() {
      return new Type.Bool;
  }

  record Var(String name, Type type) implements TypedExpr { }
}
```

The second record `Var` shows a handy shortcut to overriding the method `type`: if the record has an attribute of the right Type and name ("`type`" in this case), it will automotically become the implementation.

You can work with a variable of type `TypedExpr` like in the example above, by using `switch` expressions. If you want to avoid the `default` case, you can use a `sealed interface` instead. To make that work, you have to declare all implementations inside the interface (or use `permits`):

```java
sealed interface TypedExpr {
  record And(TypedExpr e1, TypedExpr e2) implements TypedExpr {
    Type type() {
      return new Type.Bool;
  }

  record Var(String name, Type type) implements TypedExpr { }
}
```

# How to start

This is just one way to start and the ideas given are not complete - be prepared to change everything along the way to a solution that passes all tests. To get started, here is a possible first try at an implementaion of the `typecheck` function in the `TypeChecker`:

```java
    public AnnotatedProgram typecheck(Program p) {
        var funDefs = ((PDefs) p).listdef_.stream()
                .map(def -> (DFun) def)
                .toList();
        signatures = new HashMap<>();
        extractSignatures(funDefs);
        return new AnnotatedProgram(checkFunDefs(funDefs));
    }
```

The first statement extracts a list of function definitions (from the parser) from `p` and stores it in `funDefs`. The `var` means that the type of `funDefs` is automatically infered. Then the signatures, which are stored in a field in the `TypeChecker` class, are initialized. To make the last line of this functions work, the type `AnnotatedProgram)` was modified to an inner `record` of the `TypeChecker` in the following way (the functions `extractSignatures` and `checkFunDefs` will be explained below):

```java
    record AnnotatedProgram(Map<String, TypedFunDef> defs) { }
```

The type `TypedFunDef` is also defined as an inner `record` of `TypeChecker`:

```java
    record TypedFunDef(CType returns, List<TypedArg> args, List<Statement> stms) { }
    record TypedArg(String name, CType type) { }
```

... and `Statement` and `CType` are defined in separate files:

```java
sealed interface Statement {
  record Decl(String varName, CType type) implements Statement {}
  // TODO: add more cases
}
```

```java
enum CType {
    Int, Double, Bool, Void
}
```